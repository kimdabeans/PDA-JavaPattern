# 신한투자증권 프로디지털아카데미 JAVA 디자인 패턴
## [ Adapter , Factory Method, Observer ]

### 1. Adapter Pattern
 어탭터 패턴은 호환되지 않은 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 디자인 패턴입니다.
 어댑터는 한 객체의 인터페이스를 다른 객체가 이해할 수 있도록 변환하는 특별한 객체로, 변환의 복잡성을 숨기기 위하여 객체 중 하나를 래핑​(포장)​합니다. 또한 래핑된 객체는 어댑터를 인식하지 못합니다.
 
 - 작동원리
   1. 어댑터는 기존에 있던 객체 중 하나의 호환되는 인터페이스를 받는다.
   2. 이 인터페이스를 사용하면 기존 객체는 어댑터의 메서드들을 안전하게 호출할 수 있다.
   3. 호출을 수신하면 어댑터는 이 요청을 두 번째 객체에 해당하는 객체가 예상하는 형식과 순서대로 전달한다.

      
### 1-1. Adapter Pattern 을 선택한 이유
  신한투자증권과 같은 증권업에서는 다양한 금융 상품 및 거래 유형이 존재하며, 이에 따라 다양한 환율 변환 규칙들이 필수적으로 사용되고 있습니다. 특히 환율에 기초한 통화 파생 상품 거래나 국제 거래 및 투자에 대한 사람들의 관심이 증가하는 만큼 환율 변환 및 계산 시스템은 가장 중요하면서도 기초적인 증권 분야라고 할 수 있습니다.
  
  이런 환율 변환 시스템에서는 전세계 국가들을 대상으로 거래가 일어나기 때문에 다양한 통화들을 다루고 있는데, 여기서 Adapter 패턴을 이용한다면 새로운 환율 변환 규칙이나 화폐 유형이 추가되더라도 기존 코드를 수정하지 않고 쉽게 적용할 수 있다는 장점이 있습니다. 또한 금융 기관은 다양한 외부 서비스 및 데이터 제공 업체와 연동이 필수적인데, 각각의 기관 및 기업에 따른 간의 데이터 형식이나 규격이 다를 수 있습니다. 이러한 경우에도 Adapter Pattern을 사용한다면 외부 서비스의 데이터를 시스템 내부에서 사용하기 편리하게 변환할 수 있기 때문에 유연성과 확장성 부분에서 많은 이점들이 있는 어댑터 디자인 패턴을 선택하였습니다.

  
### 1-2. Adapter Pattern UML 설명
<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/f85d9d10-6fcd-4eb8-a282-9b51abb50ade" width = "700">  

| 이름 | 설명 |
| :-----------------------: | ---- |
| Adapter | Client 클래스를 확장하여 CurrencyConverter 인터페이스를 구현한 클래스 |
| Client | Client 객체를 생성하고 환율 변환을 수행하는 클래스 |
| CurrencyConverter | 화폐 금액을 변환하는 메서드를 정의하는 인터페이스 |
| main | CurrencyConverter를 사용하여 원화를 다른 통화로 변환하는 예제를 실행하는 클래스. Adapter 인스턴스에서 변환하고 싶은 금액(원화)와 현 시점의 달러의 환율, 유로의 환율, 엔화의 환율을 입력. |


### 1-3. Adapter Pattern 을 적용하기 전과 후 비교
|  | 적용 전 (version 1.0) | 적용 후 (version 1.1) |
| :---------------: | :-------: | :-------: |
|UML|<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/a9351842-b7a2-4901-92b3-8dcc47ef2643" width = "800">|<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/f85d9d10-6fcd-4eb8-a282-9b51abb50ade" width = "600">|
| 코드 중복 및 재사용  | 원화를 다른 통화로 변환하는 메서드인 convertToDollar, convertToEuro, convertToYen 이 중복된다. | Client 클래스에 있는 원화를 통화로 변환하는 메서드를 재사용할 수 있습니다. 변환 로직을 중복 작성할 필요가 없다.  |
| 확장성 | 새로운 통화가 추가되거나 환율이 변경될 때, 모든 변환 메서드를 수정해야 하기 때문에 유지보수가 어려워진다. | 새로운 통화를 추가하거나 환율을 변경할 때, Client 클래스에 이미 있는 변환 메서드를 재사용하고, Adapter 클래스의 생성자만 수정하면 되기 때문에 다른 코드를 변경하지 않아도 된다. |
| 유연성 | 새로운 변환 방법을 추가하거나 환율 데이터를 동적으로 변경하기 어렵다. | 새로운 변환 방법을 추가하거나 환율 데이터를 동적으로 변경하기 쉽다. |

<br>

## 2. Factory Method Pattern
 팩토리 메서드 패턴은 부모 클래스에서 객체들을 생성할 수 있는 인터페이스를 제공하지만, 자식 클래스들이 생성될 객체들의 유형을 변경할 수 있도록 하는 생성 패턴입니다.
 인스턴스 생성 방법은 상위 클래스에서 결정하되, 구체적인 클래스 이름은  결정하지 않습니다. 구체적인 살은 모두 하위 클래스에서 붙이기 때문에 인스턴스 생성을 위한 뼈대와 실제 인스턴스를 생성하는 클래스를 나누어 생각할 수 있습니다.

 - 작동원리
    제품 생성 코드를 제품을 실제로 사용하는 코드와 분리합니다. 그 후 자식 클래스를 생성하여 해당 클래스 내부의 팩토리 메서드를 오버라이딩​(재정의)​ 합니다.

### 2-1. Factory Method Pattern 을 선택한 이유
 증권 업계에서는 증권 계좌, 현물 계좌, 펀드 계좌 등이 있듯이 다양한 계좌 유형을 관리가 필수적입니다. 각 계좌 유형은 서로 다른 로직 및 데이터를 처리해야 하는데 Factory Method 패턴을 사용하면 이러한 다양한 계좌 유형을 생성하는 로직을 분리하여 각 계좌 유형에 대한 Factory 클래스를 만들 수 있습니다. 그 과정 중 새로운 계좌 유형을 추가할 때 클라이언트 코드를 수정하지 않고도 새로운 계좌를 생성함으로써 시스템이 더 유연하게 확장할 수 있다는 이점이 있어 이 디자인 패턴을 선택하게 되었습니다.

### 2-2. Factory Method Pattern UML 설명
<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/8a6ff4df-40e6-4e99-9726-013baee93314" width = "700">

| 패키지 | 이름 | 설명 |
| :-------: | :-------: | :-------------: |
| framework | Factory | 추상 클래스인 Factory 클래스는 제품을 생성하고 등록하는 기능을 제공. |
| framework | Product | 제품을 나타내는 추상클래스. 추상 메소드 use만 선언되어 있음. 구체적인 use의 구현은 Product의 하위 클래스에 맡김. |
| framework | main | Factory와 Product 클래스를 사용하여 계좌(Account) 객체를 생성하고 사용. 동작 테스트용 클래스. |
| account | Account | 고객의 계좌(Account)를 나타내는 Account 클래스. Product 클래스를 상속하며, 계좌 소유자 정보와 계좌 생성 및 사용에 관한 메서드를 제공함. |
| account | AccountFactory | 계좌(Account) 객체를 생성하고 등록하는 AccountFactory 클래스. Factory 클래스를 상속하여 계좌 객체를 생성하고 등록하는 메서드를 구현함.|

### 2-3. Factory Method Pattern 을 적용하기 전과 후 비교
|  | 적용 전 (version 1.0) | 적용 후 (version 1.1) |
| :--------------------: | :-------: | :-------: |
|UML|<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/5383b91a-0682-41a9-88e9-8fce7757e267" width = "750">|<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/8a6ff4df-40e6-4e99-9726-013baee93314" width = "700">|
| 로직의 독립성  | 계좌 생성 로직이 클라이언트 코드에 포함하고 있으며, 새로운 계좌 유형을 추가하거나 변경할 때, 클라이언트 코드를 직접 수정해야 한다. | 계좌 생성 로직이 Factory 클래스로 분리되어있어 새로운 계좌 유형을 추가할 때, 클라이언트 코드를 수정 없이 해당 유형의 Factory 클래스만 수정하면 된다. |
| 코드의 유지보수성과 재사용 | 클라이언트 코드가 계좌 유형의 변화에 유연하게 대응하기 어렵다. | 새로운 계좌 유형을 쉽게 추가하거나 변경하기 쉬우며 코드 유지 보수 관리가 쉽다. |

<br>

## 3. Observer Pattern
 여러 객체에 자신이 관찰 중인 객체에 발생하는 모든 이벤트에 대하여 알리는 구독 메커니즘을 정의할 수 있도록 하는 행동 디자인 패턴입니다. 상태변화에 따른 처리를 기술할 때 효과적입니다.

 - 동작 원리
   subject 상태 변화 -> Observer로 통지 -> Observer가 Subject의 메소드 호출 -> 그에 따라 Subject 상태 변화 -> Observer로 통지 -> ...

### 3-1. Observer Pattern 을 선택한 이유
  증권 업계에서 주식 거래와 주식 가격 업데이트와 같은 상태 변화는 중요한 요소 입니다. 특히 주식 가격 및 거래 정보는 실시간으로 업데이트되어야 하며, 투자자들은 실시간으로 이러한 정보에 접근하여 투자 결정을 내리게 되어 기업의 신뢰도 유지에 중요한 역할을 합니다. 또한 주식 가격 및 거래 정보의 상태 변화를 실시간으로 전달함으로써 시장 상황의 변화에 대응하여 그에 대한 리스크를 관리해갈 수 있습니다. 
  
  이런 변동성이 많은 시스템에서 Observer Pattern은 주식 가격이 업데이트될 때마다 모든 투자자에게 즉시 알림을 제공할 수 있다는 장점이 있습니다. 뿐만 아니라 새로운 투자자 유형을 추가하거나 기존 투자자 동작을 수정하기 쉬워 시스템의 확장성과 유지보수 측면에서의 이점 또한 확인할 수 있어 옵저버 디자인 패턴을 선택하게 되었습니다.
  
### 3-2. Observer Pattern UML 설명
<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/18a011aa-69a9-4015-adbd-fc2305c63b3e" width = "700">

| 이름 | 설명 |
| :-------: | :-------------: |
| StockMarket | Subject(관찰 대상자) 역할을 하는 인터페이스이며, registerObserver, removeObserver, notifyObservers 메서드를 정의하며,이 메서드들을 구현하여 관찰자(Investor) 객체들을 등록한다. |
| StockExchange | ConcreteSubject(구체적인 관찰 대상자) 클래스 |
| Investor | Observer(관찰자) 인터페이스 |
| StockInvestorEng | ConcreteObserver(구체적인 관찰자) 클래스. 영어로 업데이트 메시지를 출력한다. |
| StockInvestorKor | ConcreteObserver(구체적인 관찰자) 클래스. 한국어로 업데이트 메시지를 출력한다. |
| main | 동작 테스트용 main 클래스 |

### 3-3. Observer Pattern 을 적용하기 전과 후 비교
|  | 적용 전 (version 1.0) | 적용 후 (version 1.1) |
| :---------------: | :-------: | :-------: |
|UML|<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/43648b06-d5e9-4bd9-8ebc-1097e4e631e0" width = "750">|<img src="https://github.com/jang294/PDA-JavaPattern/assets/98522102/18a011aa-69a9-4015-adbd-fc2305c63b3e" width = "700">|
| 의존성 및 결합도 | 주식 시장과 주식 투자자 사이에 직접적인 의존성이 존재하여, 주식 시장은 개별 투자자에게 직접 업데이트 메시지를 보내야 한다는 단점이 있다. | C느슨한 결합이 적용되어 투자자와 직접적으로 상호작용하지 않는다. |
| 코드 중복 | 주식 시장에서 주식 가격이 업데이트될 때마다, 각 투자자 클래스 내에서 업데이트 관련 코드가 중복되어 작성되어야 합니다. 새로운 투자자가 추가될 때마다 해당 투자자의 클래스도 변경되어야 한다는 단점이 있다. | 주식 시장에서 주식 가격이 업데이트될 때, 등록된 모든 투자자(Observer)에게 일괄적으로 알림을 보낼 수 있으며, 투자자 클래스 내에 중복 코드가 없어지고, 새로운 투자자 추가 시 주식 시장만 수정하면 된다. |
| 유연성 | 새로운 투자자가 추가되거나 투자자의 업데이트 방식이 변경되면 주식 시장의 코드를 변경해야한다. | 새로운 투자자를 추가하거나 투자자의 업데이트 방식을 변경해도 주식 시장의 코드를 수정할 필요가 없어 시스템 유지보수성과 확장성이 향상된다. |
